var C=Object.defineProperty;var y=r=>{throw TypeError(r)};var D=(r,e,t)=>e in r?C(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var o=(r,e,t)=>D(r,typeof e!="symbol"?e+"":e,t),E=(r,e,t)=>e.has(r)||y("Cannot "+t);var s=(r,e,t)=>(E(r,e,"read from private field"),t?t.call(r):e.get(r)),i=(r,e,t)=>e.has(r)?y("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t);import{b as a,w as S,g as l,d as n}from"./C7yO5yPs.js";var h,c,u,m,g,f,p,M,F,w;class O{constructor(){i(this,h,a(S([])));i(this,c,a(S({})));i(this,u,a(!1));i(this,m,a(null));i(this,g,a(null));i(this,f,a(!1));i(this,p,a(null));o(this,"initialize",async()=>this.initialized?this.initialized:(this.initialized=s(this,M).call(this),this.initialized));i(this,M,async()=>{const e=localStorage.getItem("openrouter_models");if(e)try{const t=JSON.parse(e);this.models=t.models||[],this.lastFetched=t.lastFetched,this.hasModels=(t.models||[]).length>0,s(this,w).call(this)}catch(t){console.error("Error parsing cached models:",t)}return this.models.length>0&&!s(this,F).call(this)?!0:this.reload()});i(this,F,()=>{if(!this.lastFetched)return!0;const e=new Date(this.lastFetched);return new Date().getTime()-e.getTime()>24*60*60*1e3});i(this,w,()=>{const e={};for(const t of this.models)e[t.id]=t;this.modelsMap=e});o(this,"load",async()=>(await this.initialize(),this.models));o(this,"reload",async()=>{if(this.loading)return!1;this.loading=!0,this.error=null;try{const e=await fetch("https://openrouter.ai/api/v1/models");if(!e.ok)throw new Error("Failed to fetch models: "+e.status);const t=await e.json();return this.models=t.data||[],this.hasModels=this.models.length>0,this.lastFetched=new Date().toISOString(),s(this,w).call(this),localStorage.setItem("openrouter_models",JSON.stringify({models:this.models,lastFetched:this.lastFetched})),!0}catch(e){return this.error=e instanceof Error?e.message:String(e),console.error("Error fetching models:",e),!1}finally{this.loading=!1}});o(this,"filterModels",(e="")=>{if(!e)return[...this.models].sort((d,z)=>z.created-d.created);const t=e.toLowerCase();return this.models.filter(d=>d.id.toLowerCase().includes(t)||d.name.toLowerCase().includes(t)).sort((d,z)=>z.created-d.created)});o(this,"hasModel",e=>e in this.modelsMap);o(this,"getModel",e=>this.modelsMap[e])}get models(){return l(s(this,h))}set models(e){n(s(this,h),e,!0)}get modelsMap(){return l(s(this,c))}set modelsMap(e){n(s(this,c),e,!0)}get loading(){return l(s(this,u))}set loading(e){n(s(this,u),e,!0)}get error(){return l(s(this,m))}set error(e){n(s(this,m),e,!0)}get lastFetched(){return l(s(this,g))}set lastFetched(e){n(s(this,g),e,!0)}get hasModels(){return l(s(this,f))}set hasModels(e){n(s(this,f),e,!0)}get initialized(){return l(s(this,p))}set initialized(e){n(s(this,p),e,!0)}}h=new WeakMap,c=new WeakMap,u=new WeakMap,m=new WeakMap,g=new WeakMap,f=new WeakMap,p=new WeakMap,M=new WeakMap,F=new WeakMap,w=new WeakMap;const b=new O;export{b as o};
