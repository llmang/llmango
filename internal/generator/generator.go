package generator

import (
	"bytes"
	"fmt"
	"os"
	"strings"

	"github.com/llmang/llmango/internal/parser"
)

// TemplateData contains data for template rendering
type TemplateData struct {
	PackageName string
	Goals       []GoalData
	Prompts     []PromptData
}

// GoalData contains goal data for template rendering
type GoalData struct {
	parser.DiscoveredGoal
	MethodName        string
	ShouldGenerateRaw bool
}

// PromptData contains prompt data for template rendering
type PromptData struct {
	parser.DiscoveredPrompt
}

// GenerateMangoFile generates the mango.go file from parsed results
func GenerateMangoFile(result *parser.ParseResult, opts *parser.GenerateOptions) error {
	// Parse templates
	tmpl, err := ParseTemplates()
	if err != nil {
		return fmt.Errorf("failed to parse templates: %w", err)
	}

	// Prepare template data
	data := TemplateData{
		PackageName: opts.PackageName,
		Goals:       make([]GoalData, 0, len(result.Goals)),
		Prompts:     make([]PromptData, 0, len(result.Prompts)),
	}

	// Process goals
	methodNames := make(map[string]bool)
	for _, goal := range result.Goals {
		methodName := generateUniqueMethodName(goal.UID, methodNames)
		methodNames[methodName] = true

		// Check if this goal should have a Raw method generated
		shouldGenerateRaw := result.RawGoalFunctions[goal.UID]

		data.Goals = append(data.Goals, GoalData{
			DiscoveredGoal:    goal,
			MethodName:        methodName,
			ShouldGenerateRaw: shouldGenerateRaw,
		})
	}

	// Process prompts
	for _, prompt := range result.Prompts {
		data.Prompts = append(data.Prompts, PromptData{
			DiscoveredPrompt: prompt,
		})
	}

	// Generate main mango.go content
	var mainBuf bytes.Buffer
	if err := tmpl.ExecuteTemplate(&mainBuf, "mangoFile", data); err != nil {
		return fmt.Errorf("failed to execute main template: %w", err)
	}

	// Generate config-based goals and prompts
	var configBuf bytes.Buffer

	// Add config goals
	for _, goal := range result.Goals {
		if goal.SourceType == "config" {
			if err := tmpl.ExecuteTemplate(&configBuf, "configGoal", goal); err != nil {
				return fmt.Errorf("failed to execute config goal template: %w", err)
			}
		}
	}

	// Add config prompts
	for _, prompt := range result.Prompts {
		if prompt.SourceType == "config" {
			if err := tmpl.ExecuteTemplate(&configBuf, "configPrompt", prompt); err != nil {
				return fmt.Errorf("failed to execute config prompt template: %w", err)
			}
		}
	}

	// Combine content
	var finalContent bytes.Buffer
	
	// Check if we need json import (if any config goals exist)
	needsJSONImport := false
	for _, goal := range result.Goals {
		if goal.SourceType == "config" {
			needsJSONImport = true
			break
		}
	}
	
	// Write package declaration and imports first
	imports := `import (
	"log"

	"github.com/llmang/llmango/llmango"
	"github.com/llmang/llmango/openrouter"
)`
	
	if needsJSONImport {
		imports = `import (
	"encoding/json"
	"log"

	"github.com/llmang/llmango/llmango"
	"github.com/llmang/llmango/openrouter"
)`
	}
	
	finalContent.WriteString(fmt.Sprintf(`// Code generated by llmango CLI. DO NOT EDIT.
package %s

%s

`, opts.PackageName, imports))

	// Write config-generated variables
	if configBuf.Len() > 0 {
		finalContent.WriteString("// Config-generated goals and prompts\n")
		finalContent.Write(configBuf.Bytes())
		finalContent.WriteString("\n")
	}

	// Write main content (without package declaration since we added it above)
	mainContent := mainBuf.String()
	// Remove the package declaration and imports from main content
	lines := strings.Split(mainContent, "\n")
	var contentStart int
	for i, line := range lines {
		if strings.HasPrefix(line, "type Mango struct") {
			contentStart = i
			break
		}
	}
	if contentStart > 0 {
		finalContent.WriteString(strings.Join(lines[contentStart:], "\n"))
	} else {
		finalContent.Write(mainBuf.Bytes())
	}

	// Write to file
	if err := os.WriteFile(opts.OutputFile, finalContent.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	return nil
}

// generateUniqueMethodName creates a unique method name from a goal UID
func generateUniqueMethodName(goalUID string, existing map[string]bool) string {
	baseName := parser.GenerateMethodName(goalUID)

	// If the base name is unique, use it
	if !existing[baseName] {
		return baseName
	}

	// Otherwise, add a suffix
	counter := 1
	for {
		candidate := fmt.Sprintf("%s%d", baseName, counter)
		if !existing[candidate] {
			return candidate
		}
		counter++
	}
}

// ValidateGoalPromptRelationships validates that all prompts reference valid goals
func ValidateGoalPromptRelationships(result *parser.ParseResult) []parser.ParseError {
	var errors []parser.ParseError

	// Create a map of goal UIDs
	goalUIDs := make(map[string]bool)
	for _, goal := range result.Goals {
		goalUIDs[goal.UID] = true
	}

	// Check that all prompts reference valid goals
	for _, prompt := range result.Prompts {
		if !goalUIDs[prompt.GoalUID] {
			errors = append(errors, parser.ParseError{
				File:    prompt.SourceFile,
				Message: fmt.Sprintf("Prompt '%s' references unknown goal '%s'", prompt.UID, prompt.GoalUID),
				Type:    "error",
			})
		}
	}

	return errors
}

// SanitizeString sanitizes a string for use in Go code generation
func SanitizeString(s string) string {
	// Escape backslashes first, then other special characters
	s = strings.ReplaceAll(s, `\`, `\\`)
	s = strings.ReplaceAll(s, `"`, `\"`)
	s = strings.ReplaceAll(s, "\n", `\n`)
	s = strings.ReplaceAll(s, "\r", `\r`)
	s = strings.ReplaceAll(s, "\t", `\t`)
	return s
}
